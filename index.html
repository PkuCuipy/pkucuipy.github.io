<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Python装饰器</title></head>
<body><blockquote><p>2021/2/16</p>
<p>Feynman Technique</p>
<p><a href='https://www.zhihu.com/question/26930016/answer/99243411'>Reference</a></p>
</blockquote>
<h2>装饰器 @decorator</h2>
<p>我们有一个函数, 想知道每次调用它都用了多长时间</p>
<pre><code class='language-python' lang='python'>def my(n):
    result = 0
    for i in range(n + 1):
        result += i
    return result
</code></pre>
<p>一种方法是我们修改函数为这个样子:</p>
<pre><code class='language-python' lang='python'>def my2(n):
    
    print(&quot;accumulate 开始运行&quot;)
    start = time.time()
    
    result = 0
    for i in range(n + 1):
        result += i

    end = time.time()
    print(&quot;accumulate 结束运行&quot;)
    print(f&quot;花费时间为{int(end-start)}ms&quot;)
    
    return result
</code></pre>
<p>你的舍友也有一个函数, 想让你帮忙测速:</p>
<pre><code class='language-python' lang='python'>def gauss(n):
    result = (1 + n) * n / 2;
    return result
</code></pre>
<p>我们当然也可以再用上面的方法修改函数, 来实现测速. 
不过这既破坏了原函数本身, 而且每当遇到一个新的函数都要修改, 太麻烦了!
然而, 我们可以定义一个 calc_time() 闭包函数, 它能实现给传入的函数前后增加计时的功能:</p>
<pre><code class='language-python' lang='python'>def calc_time(func):
    
    def func2(*args, **kwargs):
        
        print(f&quot;{func.__name__} 开始运行&quot;)
        start = time.time()
        
        return_value = func(*args, **kwargs)
        
        end = time.time()
        print(f&quot;{func.__name__} 结束运行&quot;)
        print(f&quot;花费时间为{int(end-start)}ms&quot;)
        
        return return_value
    
    return func2
</code></pre>
<p>我们用这个闭包来得到新的带测速功能的函数, 然后调用新得到的函数即可:</p>
<pre><code class='language-python' lang='python'># 得到新的函数
new_my = calc_time(my)			
new_gauss = calc_time(gauss)

# 调用并测速
new_my(10**7)
new_gauss(10**7)
</code></pre>
<p>这就是&quot;装饰&quot;的基本思想了. 不过在 python 中, 上面的写法有时可以简化. 我们只需要在定义函数时写成这个样子:</p>
<pre><code class='language-python' lang='python'>@calc_time
def foo(n):
    result = sum(range(n))
    return result
</code></pre>
<p>这就等价于:</p>
<pre><code class='language-python' lang='python'>def foo(n):
    result = sum(range(n))
    return result
foo = calc_time(foo)
</code></pre>
<p>也就是说如果我们只想得到被装饰后的函数, 那么这种通过 <code>@</code> 的写法可以简化代码. 
也就是说,</p>
<pre><code class='language-python' lang='python'>@dec
def f():
	pass
</code></pre>
<p>就等价于</p>
<pre><code class='language-python' lang='python'>def f():
	pass
f = dec(f)
</code></pre>
<p>单从语法的角度看, <code>@</code> 右边的东西只要是一个函数就可以.</p>
<p>所以如果我们见到下述写法:</p>
<pre><code class='language-python' lang='python'>@f(x, y)
def g():
	pass
</code></pre>
<p>其实就是因为 <code>f(x, y)</code> 返回值是一个函数, 然后被 <code>@</code> 的其实是 <code>f(x, y)</code> 的返回值.</p>
<p>举个例子: 比如我们想定制上述测速装饰器的功能, 可以选择是否打印&quot;开始运行&quot;和&quot;结束运行&quot;这两行字. 可以改写如下:</p>
<pre><code class='language-python' lang='python'>def calc_time(show_start, show_end):
    def decorator(func):
        def func2(*args, **kwargs):
            if show_start:							
                print(f&quot;{func.__name__} 开始运行&quot;)
            import time
            start = time.time()
            return_value = func(*args, **kwargs)
            end = time.time()
            if show_end:							
                print(f&quot;{func.__name__} 结束运行&quot;)
            print(f&quot;花费时间为{int(end-start)}ms&quot;)
            return return_value
        return func2
    return decorator

@calc_time(show_start=True, show_end=False)
def test(N):
    s = 1
    for i in range(N):
        s += 1

test(10**7)
</code></pre>
<p>也就是说 <code>calc_time(show_start=True, show_end=False)</code> 返回值是 decorator 函数, 然后相当于 <code>@decorator</code></p>
<p>最后说一句, 虽然我们用测速这个话题引出, 但这个语法本身有很多别的用法.</p>
<p>比如我们只是想把某个def块中的东西作为一个代码块来执行:</p>
<pre><code class='language-python' lang='python'>def just_run(f):
    f()
    return &quot;Done!&quot;

@just_run
def just_a_block_of_code():
    print(&quot;code line 1&quot;)
    print(&quot;code line II&quot;)
    print(&quot;code line 三&quot;)
</code></pre>
<p>或者比如 Flask 框架中, 我们可能会在代码中这么写:</p>
<pre><code class='language-python' lang='python'>@app.route(&quot;/GO&quot;, methods=[&quot;POST&quot;])
def Remainder():
    numIn = int(request.form[&quot;numIn&quot;])
    Mode = request.form.getlist(&quot;MODE&quot;)
    Msg = &quot;&quot;
    for divisor in Mode:
        tempDivisor = int(divisor)
        Msg += f&quot;{numIn}除以{tempDivisor}的余数是{numIn % tempDivisor}!&lt;br&gt;&quot;
    return render_template(&quot;remainder.html&quot;, rtnMsg=Msg)
</code></pre>
<p>然后我们去翻看 app.route 的源代码:</p>
<pre><code class='language-python' lang='python'>def route(self, rule, **options):
    
    def decorator(f):
        endpoint = options.pop(&quot;endpoint&quot;, None)
        self.add_url_rule(rule, endpoint, f, **options)
        return f

    return decorator
</code></pre>
<p>所以上面我们的代码中的 <code>@app.route(&quot;/GO&quot;, methods=[&quot;POST&quot;])</code> 就相当于:</p>
<pre><code class='language-python' lang='python'>app.add_url_rule(&#39;/GO&#39;, None, Remainder, {&quot;methods&quot;:[&quot;POST&quot;]})
</code></pre>
<p>&nbsp;</p>
</body>
</html>